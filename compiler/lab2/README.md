## 语法分析器——基于LR(1)实现 实验报告

## 陆放明 171250660

### 0. 截图

#### 0.1 源文件截图

<img src="https://i.loli.net/2019/12/17/Pbc4SOJ5lVutIA6.png" style="zoom: 50%;" />

##### 0.1.1 源代码各模块职能

- `Entry` 作为整个语法分析程序的主入口，负责对语法分析的流程总体控制
- `exception` 包主要负责异常处理，包含 **二义文法** 和 **非法文本输入** 的识别和处理
- `enclosure` 模块是对 `DFA` 中的 $\epsilon$ 闭包的抽象，包含了从闭包核扩展到闭包(状态内部转换)和根据当前闭包获取出边(状态间转换)的核心逻辑
- `LR1Item` 模块是对 *LR(1)* 项的抽象，维护了当前 *LR(1)* 项对应的 `文法规则rule`，`点dot位置`，`预测符predictiveSymbol`
- `pair`是模仿 `C++` 中的 `pair<E,T>` 所做的泛型类
- `parser` 负责语法分析中的文法规则转换，`DFA` 生成，`parsing table`的填充逻辑编织
- `parsingTable`负责对分析表进行建模处理，维护最终语法分析的映射
- `rule`维护了最初文本读入的文法规则

#### 0.2 输入文件格式截图

##### 0.2.1 文法定义文件

<img src="https://i.loli.net/2019/12/17/ApCBr3lz9UIaHso.png" style="zoom:50%;" />

##### 0.2.2 语法分析输入文本文件

<img src="/Users/mac/Library/Application Support/typora-user-images/image-20191217095659291.png" alt="image-20191217095659291" style="zoom:50%;" />



#### 0.3 语法分析——归约过程截图

<img src="/Users/mac/Library/Application Support/typora-user-images/image-20191217095857303.png" alt="image-20191217095857303" style="zoom:50%;" />

#### 0.4 `parsing tree` 生成截图

<img src="https://i.loli.net/2019/12/17/hlYCANzMj6ZksqT.png" style="zoom: 50%;" />

### 1. 语法分析步骤简介

#### 1.1 文法规则读入与建模

主要是从 `rules.txt` 文本读入相关的文法规则，我们默认最简句型为 `S` , 在读入之后便可以生成第一个闭包 `I0` , 然后进行下一步的全部闭包生成。

#### 1.2 语法分析 DFA生成

当前已经获取到闭包 `I0` , 我们需要进一步的进行状态间扩展与状态内部扩展，主要使用 *BFS* 算法来进行实现。最终可以生成完整的 `List<Enclosure> enclosures` ，用于下一步的分析表生成。

#### 1.3 语法分析表生成

填入语法分析表的步骤主要判定是 **移进项**还是 **归约项**，当某一个填入项目时，如果当前 `table cell` 已经被占用，那么当前文法必然为 **二义文法**，这里我们使用左结合律来进行二义性消除。

#### 1.4 输入文本语法分析

前面的步骤都是为当前的语法分析做准备，现在我们已经得到了 **语法分析表**，那么我们就可以基于此对给定的输入文本进行分析。如果查询语法分析表的时候，`table cell` 为空，表示**输入文本不合法**

例如我们的合法输入文本如下

```
i+i;
```

那么我们就可以给出这个句型的推导过程 （也就是程序最终的输出）

```
A->i
A->i
A->A+A
S->A
S->S;
```

### 2. 具体实现步骤

#### 2.1 文法规则读入与建模

这一步将文本格式的文法规则进行建模转换，文本规则如下

```
S->A|B|C|S;
A->A+A
A->i
B->B-B
B->j
C->C*C
C->k
```

可以看出这个是一个二义文法，我们采用左结合来进行二义性的消除。我们读入该文法内容之后，需要先加入一个**零号产生式 $S’->S$** , 基于这些 `rules` 生成若干个 *LR(1) items* ，再基于这些项来构造我们的第一个闭包。

*LR(1) item* 和闭包的建模如下

```java
//LR(1)项
public class LR1Item implements Serializable {
    public Pair<String, String> rule;   		//文法映射
    public int dotIndex;                		//点的位置
    public List<String> predictiveSymbols;	//预测符
}
//epsilon闭包
public class Enclosure {
    public Set<LR1Item> items;							//闭包包含的LR(1) item
    public String identifier;								//标识符
    public Map<String, String> outEdges = new HashMap<>();     //边名称->闭包标识符的映射
}
```

#### 2.2 语法分析 DFA生成

主要逻辑代码在 `Parser.rule2Enclosure(List<Pair<String, String>> rules, String beginSymbol)` 方法当中，算法逻辑如下：
> - 状态内部转换：先进行 *BFS* 遍历，获取到所有的闭包项目，全部加载到 `Enclosure.enclosures` 当中。注意，*BFS*过程中虽然也进行了状态间扩展，但是把这些生成的边全部丢弃 (因为当前还没有确定 *edge*出边的终点是否已经被遍历过，可能会出现 *identifier* 不唯一的情况)，而在下一步统一进行添加。此时闭包和闭包之间的连线 *edges* 还没有填充。
> - 状态间转换：根据当前的所有闭包内容，逐个闭包的进行边扩展，此时由于各个闭包已经完全确定，可以唯一确定出边的终点闭包，所以在我们的 `outEdges` 里添加各条边

根据当前闭包，获取其 $\epsilon$ 闭包的逻辑在 `Enclosure` 模块的 `Set<LR1Item> encloseOf(Set<LR1Item> core)` 当中，具体算法逻辑如下 ：

> - 给定输入 `core` 为我们的闭包核
> - 对于 `core` 中的每一个 *LR(1) item* ，设为 $R_i$， 它的预测符为 $t$
>   - 如果 $R_i$ 的 `dotIndex` 所指向的 `token` 为**终结符**， 那么就不做任何操作
>   - 如果指向的 `token` 是一个 **非终结符**， 那么设这个 **非终结符** 为 $A$ , 那么我们就把所有 $A->\alpha A\beta$ 找出，求出 $first(\beta t)$ 作为状态内转移的新的预测符内容

可以看出，如上又引出了一个新的内容：如何求解 $first(V_N) ?$ 其中 $V_N$ 为一个非终结符。

该程序也实现了 $first(V_N)$ , 具体逻辑在 `enclosure` 模块中。

#### 2.3 语法分析表填充

这一步的内容主要在模块 `parsingTable` 内部。我们先把已经得到的闭包，按照 *identifier* 进行升序排序，随后的填表算法逻辑如下：

> - 对于每一个闭包进行分析，假设当闭包为 $I_i$
>   - 对于 $I_i$ 中的每一个 $LR(1)$ *item*, 如果它不是 `isDotEnd()`，也就是可以作为 **移进项** 。于是我们查询出这个移进项对应的出边 *edge* , 获取出边终点 $I_j$ ,  那么在相应的表单元中填入 $S_j$ 即可
>   - 如果这一个 $LR(1)$ *item* 是一个 `isDotEnd()` , 也就是可以作为 **归约项**。那么我们就直接获取到当前 *LR(1) item* 的预测符内容，找到它在我们原始文法规则所对应的某一条规则 $rule_t$ , 直接填入 $r_t$ 即可
>     - 如果预测符为 $\$$ , 并且文法规则恰好为 $S’->S$  ， 那么填入 **accept**

#### 2.4 基于语法分析表来进行语法分析

当前我们已经获取到了想要的语法分析表，而进行文本分析的逻辑在 `Parser.parsingInput(ParsingTable table, String input)` ，它以语法分析表 `table` 和一行文本 `input` 作为输入，并且具有如下行为：

- 如果输入文本合法，那么就给出具体的**归约序列** (例子见 `1.4`)
- 如果输入不合法，抛出异常，打印 `Invalid input 【<input>】`

这里的基本算法实现在 `part 5 实验评价与感受` 中具体给出。 

### 3. 错误处理

#### 3.1 二义文法判定

主要由 `RuleAmbiguousException` 异常类来进行捕获，这一个异常仅会发生在如下情境

> 在我们填入语法分析表时，如果即将填入的格子已经有元素，那么就抛出 `RuleAmbiguousException` 异常，表示当前出现了 移进归约冲突 或 归约归约冲突

#### 3.2 非法输入文本判定

主要由 `InvalidInputException` 异常来进行捕获，这一个异常仅会发生在如下情境

> 基于语法分析表进行语法分析时，所查询的目标表元素为空，那么就抛出 `InvalidInputException` 异常，表示当前输入文本语法错误
>

### 4. 问题与解决方案

#### 如何进一步生成语法分析树？

前面几步的实现基本没有遇到太大的问题。课上老师鼓励我们尝试一下生成语法分析树，在这里额外分析一下解决办法。

我们再回头看一下一个合法输入 `i+i;` 的归约过程

```
A->i
A->i
A->A+A
S->A
S->S;
```

可以看出，它是对语法分析树的一个 **后序遍历**，但是仅仅根据后序遍历序列生成的二叉树并不唯一，考虑需要借助分析表的查询过程来尝试生成语法分析树。——而且这个 *parsing tree* 是一个 **多叉树**，需要从二叉树扩展。

如下给出我的分析过程：

- 对于 `A->i` ,我们可以得到，它是一个 深度为 `2` ，叶子是 `i` , 根节点是 `A` 的一棵子树。也就是说，我们把文法左部作为整个子树的根节点，叶子是右部从左向右的排列
- 子树 *merge* ：我们可以预测出，最终的整颗 *parsing tree* ,叶子节点都是 **终结符** ， 非叶节点都是 **非终结符**。那么当我们的某一个归约项右部含有 **非终结符** (例如 `A->A+A`)，我们就需要进行多颗子树的 *merge* 操作。

这里给出我自己想到的算法实现：

首先对这个 **多叉树 **进行建模

```java
private class Node {
        String identifier;
        List<Node> next;
}
```
如下是具体算法逻辑：

> - 构造一个关于 *Node* 的栈 *stack* 
> - 对于右部不含有非终结符的归约项，我们把右部直接转为左部，构造出这颗子树 *root* , 把 *root* 压栈
> - 对于右部含有非终结符的归约项，我们 **从右往左**遍历 **右部**
>   - 对于左部，直接作为根节点
>   - 遇到非终结符 $V_N$，那么就看 *stack* 栈顶和 $V_N$ 是否一致。如果不一致报错；一致则出栈，装入叶子节点
>   - 遇到终结符，直接装入叶子节点
>   - 遍历完成之后，根节点压栈
> - 最终遍历完所有的归约项之后，出栈 $root$ , 它就是我们所要的 *parsing tree*

具体代码逻辑在 `Parsing Tree`模块当中。打印逻辑主要采取 *DFS* ，最终生成的效果如下（具体运行结果都打印在console , 我已经拷贝了一份到根目录下的 `output.txt`当中）

<img src="/Users/mac/Library/Application Support/typora-user-images/image-20191217151822848.png" alt="image-20191217151822848" style="zoom:33%;" />

### 5. 实验评价与感受

最大的收获就是能够熟悉一下 **基于语法分析表分析输入文本** 的流程。这一个部分在课上转瞬即逝，符号栈和状态栈如何进行出栈入栈没怎么听懂，当时只是光顾着把流程机械的记了下来。通过代码实现之后，能够很好地理解这个流程，实际上就是 **移入** 和 **归约** 两个行为的一个抽象：

- 当表中元素 `table cell` 为 $S_i$ , 也就是 *shift* 移进操作时，其实就是把读头下的符号入栈。所以有了符号栈和状态栈同时入栈的操作。这里的编号 $i$ 是我们的闭包编号。
- 当表中元素 `table cell` 为 $r_j$ , 也就是进行 *reduction* 归约操作时，就是说，当前的符号栈栈顶的 **若干个** 元素，可以满足一个归约关系，它的归约方式如下：
> 这若干个元素按照出栈顺序排列得到的字符串 $Seq$，恰好就是 **第 $j$ 个语法规则** 的 **右部** 按照 **从右到左** 的顺序排列的 $Seq^0$。其中这里的 **第 $j$ 个语法规则** 是根据最初始的文法规则，按照我们给定的编号顺序得到的。

自此，我们就可以把右部全部出栈（符号栈和状态栈同时出栈），然后符号栈压入该文法规则的 **左部**，那么这个时候 **状态栈** 压入什么呢？ 

> *table-goto\[topStateStack]\[topSymbolStack]*

我把这一步状态栈压栈也理解为是一种 **特殊** 的移入操作。

- 我们实际上是在符号栈移入了一个 `rule` 的左部，它必定是一个 **非终结符**，那么我们就需要在 *goto* 子表中查询。和原来的 *shift* 逻辑一致：我们根据 **读头下的符号** 和 **状态栈栈顶** 来查询下一步入栈的元素内容。这样一来，我们就可以假设之前读头下就是表达式左部 $E$，之后才有的 $E$ 入栈。那么移入之前查询的就是 *table-goto\[topStateStack]\[E]* = *table-goto\[topStateStack]\[topSymbolStack]*